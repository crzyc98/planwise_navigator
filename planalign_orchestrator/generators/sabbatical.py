"""
Sabbatical Event Generator

Example implementation demonstrating the event type abstraction layer (E004).
This generator creates sabbatical leave events for long-tenured employees.

Sabbaticals are typically offered to employees with 7+ years of tenure
for personal development, academic pursuits, or rest.
"""

from __future__ import annotations

import logging
from datetime import date, timedelta
from decimal import Decimal
from typing import TYPE_CHECKING, List

from planalign_orchestrator.generators.base import (
    EventContext,
    EventGenerator,
    ValidationResult,
)
from planalign_orchestrator.generators.registry import EventRegistry

if TYPE_CHECKING:
    from config.events import SimulationEvent

logger = logging.getLogger(__name__)


@EventRegistry.register("sabbatical")
class SabbaticalEventGenerator(EventGenerator):
    """
    Generate sabbatical leave events for eligible employees.

    Eligibility criteria:
    - Minimum 7 years of tenure
    - Not currently on leave
    - Not scheduled for termination in simulation year

    Sabbatical selection is deterministic based on random seed,
    targeting approximately 2% of eligible employees per year.
    """

    event_type = "sabbatical"
    execution_order = 35  # After terminations (20), before promotions (40)
    requires_hazard = False
    supports_sql = True
    supports_polars = False

    # Configuration defaults
    MIN_TENURE_YEARS: int = 7
    SELECTION_RATE: float = 0.02  # 2% of eligible employees
    DEFAULT_DURATION_WEEKS: int = 8
    DEFAULT_COMPENSATION_PERCENTAGE: Decimal = Decimal("0.5")

    def generate_events(self, context: EventContext) -> List["SimulationEvent"]:
        """
        Generate sabbatical events for the simulation year.

        In SQL mode, delegates to dbt model for event generation.
        This method provides the Python interface for the abstraction layer.

        Args:
            context: Runtime context with year, config, database access

        Returns:
            List of SimulationEvent instances (empty for SQL mode)
        """
        # For SQL mode, events are generated by dbt model
        # This method returns empty list as events come from database
        if context.config.get("event_mode", "sql") == "sql":
            logger.debug(
                f"sabbatical: SQL mode - events generated by dbt model for year {context.simulation_year}"
            )
            return []

        # Polars mode implementation would go here
        # For now, return empty as polars mode is not yet supported
        logger.debug(
            f"sabbatical: No Polars implementation yet for year {context.simulation_year}"
        )
        return []

    def validate_event(self, event: "SimulationEvent") -> ValidationResult:
        """
        Validate a sabbatical event.

        Validates:
        - Event type matches "sabbatical"
        - start_date and end_date are present
        - end_date is after start_date
        - compensation_percentage is between 0 and 1
        - reason is valid

        Args:
            event: The sabbatical event to validate

        Returns:
            ValidationResult with is_valid flag and any errors/warnings
        """
        errors: List[str] = []
        warnings: List[str] = []

        # Check event type
        if event.payload.event_type != "sabbatical":
            errors.append(
                f"Expected event_type 'sabbatical', got '{event.payload.event_type}'"
            )
            return ValidationResult(is_valid=False, errors=errors)

        # Access sabbatical-specific fields
        payload = event.payload

        # Validate dates
        if not hasattr(payload, "start_date") or payload.start_date is None:
            errors.append("start_date is required")
        if not hasattr(payload, "end_date") or payload.end_date is None:
            errors.append("end_date is required")

        if errors:
            return ValidationResult(is_valid=False, errors=errors)

        # Check date ordering
        if payload.end_date <= payload.start_date:
            errors.append("end_date must be after start_date")

        # Check duration (warn if unusual)
        duration = (payload.end_date - payload.start_date).days
        if duration < 7:
            warnings.append(f"Sabbatical duration ({duration} days) is unusually short")
        if duration > 365:
            warnings.append(f"Sabbatical duration ({duration} days) exceeds one year")

        # Validate compensation percentage
        if hasattr(payload, "compensation_percentage"):
            comp_pct = payload.compensation_percentage
            if comp_pct < Decimal("0") or comp_pct > Decimal("1"):
                errors.append(
                    f"compensation_percentage must be between 0 and 1, got {comp_pct}"
                )

        # Validate reason
        valid_reasons = {"academic", "personal", "medical", "community_service"}
        if hasattr(payload, "reason"):
            if payload.reason not in valid_reasons:
                errors.append(
                    f"Invalid reason '{payload.reason}'. Must be one of: {valid_reasons}"
                )

        return ValidationResult(
            is_valid=len(errors) == 0, errors=errors, warnings=warnings
        )

    def get_eligible_employees(self, context: EventContext) -> List[dict]:
        """
        Query eligible employees for sabbatical.

        Eligibility:
        - Active employee (not terminated)
        - Tenure >= MIN_TENURE_YEARS
        - No existing sabbatical in current year

        Args:
            context: Runtime context for database access

        Returns:
            List of employee dictionaries with id, tenure, etc.
        """

        def _query(conn):
            return conn.execute(
                f"""
                SELECT DISTINCT
                    w.employee_id,
                    w.tenure_years,
                    w.age,
                    w.department,
                    w.annual_compensation
                FROM fct_workforce_snapshot w
                WHERE w.simulation_year = {context.simulation_year}
                  AND w.scenario_id = '{context.scenario_id}'
                  AND w.tenure_years >= {self.MIN_TENURE_YEARS}
                  AND w.is_active = true
                  AND NOT EXISTS (
                    SELECT 1 FROM fct_yearly_events e
                    WHERE e.employee_id = w.employee_id
                      AND e.scenario_id = w.scenario_id
                      AND e.simulation_year = w.simulation_year
                      AND e.event_type = 'sabbatical'
                  )
                """
            ).fetchall()

        result = context.db_manager.execute_with_retry(_query)
        return [
            {
                "employee_id": r[0],
                "tenure_years": float(r[1]),
                "age": float(r[2]) if r[2] else None,
                "department": r[3],
                "annual_compensation": Decimal(str(r[4])) if r[4] else None,
            }
            for r in result
        ]

    def calculate_sabbatical_dates(
        self, employee: dict, context: EventContext
    ) -> tuple[date, date]:
        """
        Calculate sabbatical start and end dates.

        Default: 8-week sabbatical starting on July 1st.

        Args:
            employee: Employee dictionary
            context: Runtime context

        Returns:
            Tuple of (start_date, end_date)
        """
        start_date = date(context.simulation_year, 7, 1)
        end_date = start_date + timedelta(weeks=self.DEFAULT_DURATION_WEEKS)
        return start_date, end_date

    def determine_compensation_percentage(self, employee: dict) -> Decimal:
        """
        Determine compensation continuation percentage.

        Higher tenure = higher compensation:
        - 7-10 years: 50%
        - 10-15 years: 75%
        - 15+ years: 100%

        Args:
            employee: Employee dictionary with tenure_years

        Returns:
            Decimal percentage (0.0 to 1.0)
        """
        tenure = employee.get("tenure_years", 0)

        if tenure >= 15:
            return Decimal("1.0")
        elif tenure >= 10:
            return Decimal("0.75")
        else:
            return Decimal("0.50")
