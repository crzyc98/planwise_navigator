"""
Hire Event Generator Wrapper (T023)

Thin wrapper around existing dbt hire event models.
Delegates event generation to SQL models while providing
the EventGenerator interface for the abstraction layer.
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, List

from planalign_orchestrator.generators.base import (
    EventContext,
    EventGenerator,
    ValidationResult,
)
from planalign_orchestrator.generators.registry import EventRegistry

if TYPE_CHECKING:
    from config.events import SimulationEvent

logger = logging.getLogger(__name__)


@EventRegistry.register("hire")
class HireEventGenerator(EventGenerator):
    """
    Generate hire events for workforce simulation.

    This wrapper delegates to existing dbt models:
    - int_hiring_events: New employee generation based on workforce growth

    Hiring events create new employees to meet workforce growth targets,
    with demographics sampled from configurable distributions.

    Execution Order: 20 (after terminations, to backfill)
    """

    event_type = "hire"
    execution_order = 20
    requires_hazard = False  # Hiring uses growth targets, not hazard tables
    supports_sql = True
    supports_polars = True  # Has Polars implementation

    # dbt model references
    dbt_models = ["int_hiring_events"]

    def generate_events(self, context: EventContext) -> List["SimulationEvent"]:
        """
        Generate hire events for the simulation year.

        In SQL mode, this delegates to dbt models which handle:
        - Workforce needs calculation
        - New hire demographic generation
        - Employee ID assignment

        Args:
            context: Runtime context with year, config, database access

        Returns:
            Empty list in SQL mode (events generated by dbt)
        """
        mode = context.config.get("event_mode", "sql") if hasattr(context.config, "get") else "sql"

        if mode == "sql":
            logger.debug(
                f"hire: SQL mode - events generated by dbt model "
                f"int_hiring_events for year {context.simulation_year}"
            )
            return []

        logger.debug(
            f"hire: Polars mode - events generated by polars_event_factory "
            f"for year {context.simulation_year}"
        )
        return []

    def validate_event(self, event: "SimulationEvent") -> ValidationResult:
        """
        Validate a hire event.

        Validates:
        - Event type is "hire"
        - hire_date is present
        - department is not empty
        - job_level is within valid range (1-10)
        - annual_compensation is positive

        Args:
            event: The hire event to validate

        Returns:
            ValidationResult with is_valid flag and any errors
        """
        errors: List[str] = []
        warnings: List[str] = []

        # Check event type
        payload = event.payload
        if payload.event_type != "hire":
            errors.append(f"Expected event_type 'hire', got '{payload.event_type}'")
            return ValidationResult(is_valid=False, errors=errors)

        # Validate hire_date
        if not hasattr(payload, "hire_date") or payload.hire_date is None:
            errors.append("hire_date is required")

        # Validate department
        if hasattr(payload, "department"):
            if not payload.department or not payload.department.strip():
                errors.append("department cannot be empty")
        else:
            errors.append("department is required")

        # Validate job_level
        if hasattr(payload, "job_level"):
            if payload.job_level < 1 or payload.job_level > 10:
                errors.append(f"job_level must be between 1 and 10, got {payload.job_level}")
        else:
            errors.append("job_level is required")

        # Validate annual_compensation
        if hasattr(payload, "annual_compensation"):
            if payload.annual_compensation <= 0:
                errors.append(
                    f"annual_compensation must be positive, got {payload.annual_compensation}"
                )
        else:
            errors.append("annual_compensation is required")

        return ValidationResult(
            is_valid=len(errors) == 0, errors=errors, warnings=warnings
        )

    def get_dbt_models(self) -> List[str]:
        """Get list of dbt models for this generator."""
        return self.dbt_models
