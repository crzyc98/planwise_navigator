"""
Merit Event Generator Wrapper (T025)

Thin wrapper around existing dbt merit event models.
Delegates event generation to SQL models while providing
the EventGenerator interface for the abstraction layer.
"""

from __future__ import annotations

import logging
from decimal import Decimal
from typing import TYPE_CHECKING, List

from planalign_orchestrator.generators.base import (
    EventContext,
    EventGenerator,
    ValidationResult,
    HazardBasedEventGeneratorMixin,
)
from planalign_orchestrator.generators.registry import EventRegistry

if TYPE_CHECKING:
    from config.events import SimulationEvent

logger = logging.getLogger(__name__)


@EventRegistry.register("merit")
class MeritEventGenerator(HazardBasedEventGeneratorMixin, EventGenerator):
    """
    Generate merit (raise) events for workforce simulation.

    This wrapper delegates to existing dbt models:
    - int_hazard_merit: Hazard probability calculation
    - int_merit_events: Final merit event generation

    Merit increases use hazard probability tables and performance
    distributions to determine compensation adjustments.

    Execution Order: 40 (after promotions, before enrollment)
    """

    event_type = "merit"
    execution_order = 40
    requires_hazard = True
    supports_sql = True

    # dbt model references
    dbt_models = ["int_hazard_merit", "int_merit_events"]
    hazard_table_name = "config_merit_hazard"

    def generate_events(self, context: EventContext) -> List["SimulationEvent"]:
        """
        Generate merit events for the simulation year.

        Delegates to dbt models which handle:
        - Hazard-based merit selection
        - Merit percentage calculation
        - New compensation determination

        Args:
            context: Runtime context with year, config, database access

        Returns:
            Empty list (events generated by dbt)
        """
        logger.debug(
            f"merit: events generated by dbt models "
            f"{self.dbt_models} for year {context.simulation_year}"
        )
        return []

    def validate_event(self, event: "SimulationEvent") -> ValidationResult:
        """
        Validate a merit event.

        Validates:
        - Event type is "merit"
        - new_compensation is positive
        - merit_percentage is between 0 and 1

        Args:
            event: The merit event to validate

        Returns:
            ValidationResult with is_valid flag and any errors
        """
        errors: List[str] = []
        warnings: List[str] = []

        # Check event type
        payload = event.payload
        if payload.event_type != "merit":
            errors.append(f"Expected event_type 'merit', got '{payload.event_type}'")
            return ValidationResult(is_valid=False, errors=errors)

        # Validate new_compensation
        if hasattr(payload, "new_compensation"):
            if payload.new_compensation <= 0:
                errors.append(
                    f"new_compensation must be positive, got {payload.new_compensation}"
                )
        else:
            errors.append("new_compensation is required")

        # Validate merit_percentage
        if hasattr(payload, "merit_percentage"):
            pct = payload.merit_percentage
            if pct < Decimal("0") or pct > Decimal("1"):
                errors.append(
                    f"merit_percentage must be between 0 and 1, got {pct}"
                )
            # Warn if unusually high
            if pct > Decimal("0.25"):
                warnings.append(
                    f"merit_percentage {pct} is unusually high (>25%)"
                )
        else:
            errors.append("merit_percentage is required")

        return ValidationResult(
            is_valid=len(errors) == 0, errors=errors, warnings=warnings
        )

    def get_dbt_models(self) -> List[str]:
        """Get list of dbt models for this generator."""
        return self.dbt_models
