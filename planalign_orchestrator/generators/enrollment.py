"""
Enrollment Event Generator Wrapper (T026)

Thin wrapper around existing dbt enrollment event models.
Delegates event generation to SQL models while providing
the EventGenerator interface for the abstraction layer.
"""

from __future__ import annotations

import logging
from decimal import Decimal
from typing import TYPE_CHECKING, List

from planalign_orchestrator.generators.base import (
    EventContext,
    EventGenerator,
    ValidationResult,
)
from planalign_orchestrator.generators.registry import EventRegistry

if TYPE_CHECKING:
    from config.events import SimulationEvent

logger = logging.getLogger(__name__)


@EventRegistry.register("enrollment")
class EnrollmentEventGenerator(EventGenerator):
    """
    Generate enrollment events for DC plan participation.

    This wrapper delegates to existing dbt models:
    - int_eligibility_determination: Plan eligibility checks
    - int_voluntary_enrollment_decision: Employee enrollment decisions
    - int_proactive_voluntary_enrollment: Proactive enrollment handling
    - int_enrollment_events: Final enrollment event generation

    Enrollment handles DC plan participation including auto-enrollment,
    voluntary enrollment, and deferral rate elections.

    Execution Order: 50 (last major event type)
    """

    event_type = "enrollment"
    execution_order = 50
    requires_hazard = False  # Enrollment uses eligibility rules, not hazard
    supports_sql = True
    supports_polars = True  # Has Polars implementation

    # dbt model references
    dbt_models = [
        "int_eligibility_determination",
        "int_voluntary_enrollment_decision",
        "int_proactive_voluntary_enrollment",
        "int_enrollment_events",
        "int_deferral_rate_escalation_events",
    ]

    def generate_events(self, context: EventContext) -> List["SimulationEvent"]:
        """
        Generate enrollment events for the simulation year.

        In SQL mode, this delegates to dbt models which handle:
        - Eligibility determination
        - Auto-enrollment processing
        - Voluntary enrollment decisions
        - Deferral rate elections

        Args:
            context: Runtime context with year, config, database access

        Returns:
            Empty list in SQL mode (events generated by dbt)
        """
        mode = context.config.get("event_mode", "sql") if hasattr(context.config, "get") else "sql"

        if mode == "sql":
            logger.debug(
                f"enrollment: SQL mode - events generated by dbt models "
                f"for year {context.simulation_year}"
            )
            return []

        logger.debug(
            f"enrollment: Polars mode - events generated by polars_event_factory "
            f"for year {context.simulation_year}"
        )
        return []

    def validate_event(self, event: "SimulationEvent") -> ValidationResult:
        """
        Validate an enrollment event.

        Validates:
        - Event type is "enrollment"
        - enrollment_date is present
        - contribution rates are valid (0-1)
        - plan_id is present

        Args:
            event: The enrollment event to validate

        Returns:
            ValidationResult with is_valid flag and any errors
        """
        errors: List[str] = []
        warnings: List[str] = []

        # Check event type
        payload = event.payload
        if payload.event_type != "enrollment":
            errors.append(
                f"Expected event_type 'enrollment', got '{payload.event_type}'"
            )
            return ValidationResult(is_valid=False, errors=errors)

        # Validate enrollment_date
        if not hasattr(payload, "enrollment_date") or payload.enrollment_date is None:
            errors.append("enrollment_date is required")

        # Validate plan_id
        if hasattr(payload, "plan_id"):
            if not payload.plan_id or not payload.plan_id.strip():
                errors.append("plan_id cannot be empty")
        else:
            errors.append("plan_id is required")

        # Validate contribution rates
        rate_fields = [
            "pre_tax_contribution_rate",
            "roth_contribution_rate",
            "after_tax_contribution_rate",
        ]
        for field in rate_fields:
            if hasattr(payload, field):
                rate = getattr(payload, field)
                if rate < Decimal("0") or rate > Decimal("1"):
                    errors.append(f"{field} must be between 0 and 1, got {rate}")

        # Check total contribution rate
        if hasattr(payload, "pre_tax_contribution_rate") and hasattr(
            payload, "roth_contribution_rate"
        ):
            total = payload.pre_tax_contribution_rate + payload.roth_contribution_rate
            if hasattr(payload, "after_tax_contribution_rate"):
                total += payload.after_tax_contribution_rate
            if total > Decimal("1"):
                warnings.append(
                    f"Total contribution rate ({total}) exceeds 100%"
                )

        return ValidationResult(
            is_valid=len(errors) == 0, errors=errors, warnings=warnings
        )

    def get_dbt_models(self) -> List[str]:
        """Get list of dbt models for this generator."""
        return self.dbt_models
