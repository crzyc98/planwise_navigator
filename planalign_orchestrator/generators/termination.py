"""
Termination Event Generator Wrapper (T022)

Thin wrapper around existing dbt termination event models.
Delegates event generation to SQL models while providing
the EventGenerator interface for the abstraction layer.
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, List

from planalign_orchestrator.generators.base import (
    EventContext,
    EventGenerator,
    ValidationResult,
    HazardBasedEventGeneratorMixin,
)
from planalign_orchestrator.generators.registry import EventRegistry

if TYPE_CHECKING:
    from config.events import SimulationEvent

logger = logging.getLogger(__name__)


@EventRegistry.register("termination")
class TerminationEventGenerator(HazardBasedEventGeneratorMixin, EventGenerator):
    """
    Generate termination events for workforce simulation.

    This wrapper delegates to existing dbt models:
    - int_termination_events: Main termination event generation
    - int_new_hire_termination_events: First-year termination handling

    Termination uses hazard probability tables based on age and tenure bands
    to determine which employees leave during the simulation year.

    Execution Order: 10 (first event type, before hires)
    """

    event_type = "termination"
    execution_order = 10
    requires_hazard = True
    supports_sql = True

    # dbt model references
    dbt_models = [
        "int_termination_events",
        "int_new_hire_termination_events",
    ]
    hazard_table_name = "config_termination_hazard"

    def generate_events(self, context: EventContext) -> List["SimulationEvent"]:
        """
        Generate termination events for the simulation year.

        Delegates to dbt models which handle:
        - Hazard-based termination selection
        - First-year new hire terminations
        - Deterministic RNG using hash_rng macro

        Args:
            context: Runtime context with year, config, database access

        Returns:
            Empty list (events generated by dbt)
        """
        logger.debug(
            f"termination: events generated by dbt models "
            f"{self.dbt_models} for year {context.simulation_year}"
        )
        return []

    def validate_event(self, event: "SimulationEvent") -> ValidationResult:
        """
        Validate a termination event.

        Validates:
        - Event type is "termination"
        - termination_reason is valid
        - final_pay_date is present

        Args:
            event: The termination event to validate

        Returns:
            ValidationResult with is_valid flag and any errors
        """
        errors: List[str] = []
        warnings: List[str] = []

        # Check event type
        payload = event.payload
        if payload.event_type != "termination":
            errors.append(
                f"Expected event_type 'termination', got '{payload.event_type}'"
            )
            return ValidationResult(is_valid=False, errors=errors)

        # Validate termination reason
        valid_reasons = {"voluntary", "involuntary", "retirement", "death", "disability"}
        if hasattr(payload, "termination_reason"):
            if payload.termination_reason not in valid_reasons:
                errors.append(
                    f"Invalid termination_reason '{payload.termination_reason}'. "
                    f"Must be one of: {valid_reasons}"
                )
        else:
            errors.append("termination_reason is required")

        # Validate final_pay_date
        if not hasattr(payload, "final_pay_date") or payload.final_pay_date is None:
            errors.append("final_pay_date is required")

        return ValidationResult(
            is_valid=len(errors) == 0, errors=errors, warnings=warnings
        )

    def get_dbt_models(self) -> List[str]:
        """Get list of dbt models for this generator."""
        return self.dbt_models
