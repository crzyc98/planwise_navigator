# Implementation Plan: Fix Service-Based Core Contribution Calculation

**Branch**: `009-fix-service-based-core-contribution` | **Date**: 2026-01-05 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/009-fix-service-based-core-contribution/spec.md`

## Summary

Fix the `int_employer_core_contributions.sql` dbt model to read and apply service-based (graded by service) core contribution tiers. The model currently ignores the `employer_core_status` and `employer_core_graded_schedule` variables exported by the configuration system, always applying the flat rate regardless of configuration.

## Technical Context

**Language/Version**: SQL (DuckDB 1.0.0), dbt-core 1.8.8 + dbt-duckdb 1.8.1
**Primary Dependencies**: dbt, DuckDB, existing `int_employer_core_contributions.sql` model
**Storage**: DuckDB (`dbt/simulation.duckdb`)
**Testing**: dbt tests, pytest for integration tests
**Target Platform**: Linux/macOS (work laptop deployments)
**Project Type**: Single dbt project with Python orchestrator
**Performance Goals**: No regression from existing model performance
**Constraints**: Must maintain backward compatibility with flat-rate configurations
**Scale/Scope**: 100K+ employee simulations

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Evidence |
|-----------|--------|----------|
| I. Event Sourcing & Immutability | ✅ Pass | Contribution events recorded with applied tier for audit trail (FR-007) |
| II. Modular Architecture | ✅ Pass | Fix contained within single model; no new modules required |
| III. Test-First Development | ✅ Pass | Acceptance scenarios defined; dbt tests will be added |
| IV. Enterprise Transparency | ✅ Pass | Applied service tier recorded in contribution events |
| V. Type-Safe Configuration | ✅ Pass | Uses existing Pydantic-validated graded_schedule export |
| VI. Performance & Scalability | ✅ Pass | No additional complexity; join on existing tenure data |

**Gate Status**: ✅ PASS - All principles satisfied

## Project Structure

### Documentation (this feature)

```text
specs/009-fix-service-based-core-contribution/
├── plan.md              # This file
├── research.md          # Phase 0 output - Bug investigation findings
├── data-model.md        # Phase 1 output - Service tier structure
├── quickstart.md        # Phase 1 output - Testing guide
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
dbt/
├── models/
│   └── intermediate/
│       └── int_employer_core_contributions.sql  # PRIMARY FIX LOCATION
└── tests/
    └── test_service_tier_core_contributions.sql # New dbt test

tests/
├── integration/
│   └── test_service_tier_contributions.py      # Integration test
└── fixtures/
    └── service_tier_scenarios.py               # Test fixtures
```

**Structure Decision**: Bug fix within existing dbt model structure. No new modules required.

## Complexity Tracking

> No complexity violations. Fix is contained within a single existing model.

---

## Phase 0: Research Findings

### Bug Investigation

**Bug Location Confirmed**: `/workspace/dbt/models/intermediate/int_employer_core_contributions.sql`

**Root Cause Analysis**:

1. **Variables Not Read** (Lines 38-47): The model reads `employer_core_enabled` and `employer_core_contribution_rate` but does NOT read:
   - `employer_core_status` (values: 'none', 'flat', 'graded_by_service')
   - `employer_core_graded_schedule` (list of tier objects)

2. **Tenure Data Not Joined** (Lines 193-199): The `snapshot_flags` CTE only selects:
   - `employee_id`
   - `detailed_status_code`

   Missing: `current_tenure` which is available in `int_workforce_snapshot_optimized`

3. **Hardcoded Flat Rate** (Lines 246, 274): The contribution calculation always uses:
   ```sql
   * {{ employer_core_contribution_rate }}
   ```
   No conditional logic checks `employer_core_status` to switch between flat and graded modes.

**Configuration Export Working Correctly**:
- `/workspace/planalign_orchestrator/config/export.py` (lines 621-631) correctly exports:
  - `employer_core_status`: 'none', 'flat', or 'graded_by_service'
  - `employer_core_graded_schedule`: List of `{min_years, max_years, rate}` objects

**Data Flow**:
```
UI Configuration → dc_plan.core_status = 'graded_by_service'
                → dc_plan.core_graded_schedule = [{min_years: 0, max_years: 10, rate: 6}, ...]
       ↓
Export (config/export.py) → dbt_vars["employer_core_status"] = 'graded_by_service'
                          → dbt_vars["employer_core_graded_schedule"] = [...]
       ↓
int_employer_core_contributions.sql [BUG: Variables ignored, flat rate applied]
       ↓
All employees get flat rate (8%) regardless of tenure
```

### Implementation Approach

**Decision**: Implement tier lookup using dbt Jinja with SQL CASE expression

**Rationale**:
- Avoids complex Jinja loops at runtime
- DuckDB handles CASE efficiently with vectorized execution
- Pattern matches existing hazard band assignment macros

**Alternatives Considered**:
1. ~~Jinja for-loop to build dynamic SQL~~ - Complex, harder to debug
2. ~~Python preprocessing of tiers~~ - Adds orchestrator dependency
3. **SQL CASE statement** ✅ - Simple, efficient, maintainable

### Tier Matching Logic

```sql
-- Tier lookup using [min, max) convention
CASE
  WHEN employer_core_status = 'graded_by_service' THEN
    CASE
      WHEN years_of_service >= 10 THEN 0.08  -- tier 2
      WHEN years_of_service >= 0 THEN 0.06   -- tier 1
      ELSE 0.08  -- fallback to highest tier
    END
  ELSE employer_core_contribution_rate  -- flat rate
END
```

---

## Phase 1: Design

### Data Model

See [data-model.md](./data-model.md) for complete entity definitions.

**Key Entities**:

| Entity | Description | Key Fields |
|--------|-------------|------------|
| Service Tier | Rate configuration for tenure range | `min_years`, `max_years`, `rate` |
| Core Contribution | Employer contribution with tier audit | `employee_id`, `employer_core_amount`, `applied_tier_min_years`, `applied_core_rate` |

### Contract Changes

**dbt Variable Contract** (existing, now read):
```yaml
employer_core_status: string  # 'none' | 'flat' | 'graded_by_service'
employer_core_graded_schedule:  # List of tier objects
  - min_years: int
    max_years: int | null  # null = infinity
    rate: float  # Decimal rate (e.g., 0.06 for 6%)
```

**Output Schema Enhancement** (int_employer_core_contributions):
```sql
-- New audit fields
applied_tier_min_years INT,      -- Service tier that was applied
applied_core_rate DECIMAL(5,4)   -- Actual rate used (may differ from standard_core_rate)
```

### Implementation Checklist

1. **Read graded schedule variables** (Lines 38-47):
   ```sql
   {% set employer_core_status = var('employer_core_status', 'flat') %}
   {% set employer_core_graded_schedule = var('employer_core_graded_schedule', []) %}
   ```

2. **Add tenure to snapshot_flags CTE** (Lines 193-199):
   ```sql
   SELECT
       employee_id,
       detailed_status_code,
       FLOOR(current_tenure) AS years_of_service  -- Integer years
   FROM {{ ref('int_workforce_snapshot_optimized') }}
   ```

3. **Create tier lookup macro** (new file or inline):
   ```sql
   {% macro get_tiered_core_rate(years_of_service, graded_schedule, flat_rate) %}
   CASE
     {% for tier in graded_schedule | sort(attribute='min_years', reverse=true) %}
     WHEN {{ years_of_service }} >= {{ tier.min_years }} THEN {{ tier.rate / 100.0 }}
     {% endfor %}
     ELSE {{ flat_rate }}
   END
   {% endmacro %}
   ```

4. **Update contribution calculation** (Line 246):
   ```sql
   CASE
     WHEN '{{ employer_core_status }}' = 'graded_by_service' THEN
       {{ get_tiered_core_rate('snap.years_of_service', employer_core_graded_schedule, employer_core_contribution_rate) }}
     ELSE {{ employer_core_contribution_rate }}
   END
   ```

5. **Add audit fields to output**:
   ```sql
   snap.years_of_service AS applied_years_of_service,
   -- Applied tier tracking for audit
   ```

6. **Add dbt tests**:
   - Test: Employees with 5 years tenure get 6% when configured
   - Test: Employees with 15 years tenure get 8% when configured
   - Test: Flat rate applied when graded_by_service disabled

---

## Quickstart

See [quickstart.md](./quickstart.md) for step-by-step testing guide.

**Quick Validation**:
```bash
# 1. Configure scenario with service tiers in PlanAlign Studio
# 2. Run simulation
planalign simulate 2025 --verbose

# 3. Verify tier application
duckdb dbt/simulation.duckdb "
SELECT
  years_of_service,
  COUNT(*) as employees,
  AVG(core_contribution_rate) as avg_rate
FROM int_employer_core_contributions
WHERE simulation_year = 2025
GROUP BY years_of_service
ORDER BY years_of_service
"
```
